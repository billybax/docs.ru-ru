---
title: Architecture
ms.date: 03/30/2017
helpviewer_keywords:
- properties [WPF], attached
- attached properties [WPF]
- architecture [WPF]
- unmanaged components [WPF]
- affinity thread [WPF]
- Storyboards [WPF]
- milcore [WPF]
- components [WPF], unmanaged
- painter's algorithm
- interfaces [WPF], INotifyPropertyChange
- CommandBindings [WPF]
- data templates [WPF]
- thread [WPF], affinity
ms.assetid: 8579c10b-76ab-4c52-9691-195ce02333c8
ms.openlocfilehash: b16be8470a47f3e8e362feb0b13e10aa901baacb
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/12/2020
ms.locfileid: "79187122"
---
# <a name="wpf-architecture"></a>Архитектура WPF
Эта тема содержит экскурсию по иерархии классов Фонда презентаций Windows (WPF). Он охватывает большинство основных подсистем WPF и описывает, как они взаимодействуют. В нем также подробно описаны некоторые варианты, сделанные архитекторами WPF.  

<a name="System_Object"></a>
## <a name="systemobject"></a>System.Object  
 Основная модель программирования WPF подвергается через управляемый код. На раннем этапе проектирования WPF был проведен ряд дискуссий о том, где следует провести грань между управляемыми компонентами системы и неуправляемыми. CLR предоставляет ряд функций, которые делают разработку более продуктивной и надежной (включая управление памятью, обработку ошибок, общую систему типов и т.д.), но они приходят на стоимость.  
  
 Основные компоненты ВПФ приведены на рисунке ниже. Красные разделы диаграммы (PresentationFramework, PresentationCore и milcore) являются основными частями кода WPF. Только один из этих компонентов является неуправляемым — milcore. Milcore написан в неуправляемом коде, чтобы обеспечить тесную интеграцию с DirectX. Все отображение в WPF осуществляется через движок DirectX, что позволяет эффективное оборудование и программное обеспечение рендеринга. WPF также требует тонкого контроля за памятью и исполнением. Двигатель композиции в milcore чрезвычайно чувствителен к производительности и требует отказа от многих преимуществ CLR, чтобы получить производительность.  
  
 ![Размещение WPF в платформе .NET Framework.](./media/wpf-architect1.PNG "wpf_architect1")  
  
 Связь между управляемыми и неуправляемыми частями WPF обсуждается позже в этой теме. Остальная часть управляемой модели программирования описана ниже.  
  
<a name="System_Threading_DispatcherObject"></a>
## <a name="systemthreadingdispatcherobject"></a>System.Threading.DispatcherObject  
 Большинство объектов в <xref:System.Windows.Threading.DispatcherObject>WPF вытекают из , который обеспечивает основные конструкции для борьбы с параллелью и резьбой. WPF основан на системе обмена сообщениями, внедряемых диспетчером. Это работает так же, как знакомый Win32 сообщение насоса; на самом деле диспетчер WPF использует сообщения User32 для выполнения перекрестных потоков.  
  
 Есть действительно две основные концепции, чтобы понять при обсуждении параллелизма в WPF - диспетчер и сродство потока.  
  
 На этапе проектирования WPF цель состояла в том, чтобы перейти к одной нити выполнения, но непоток "аффинитизированной" модели. Сходство потоков случается, когда компонент использует идентификатор выполняемого потока для сохранения некоторых типов состояния. Наиболее распространенной формой этого является использование локальной памяти потока (TLS) для сохранения состояния. Сходство потоков требует, чтобы каждый логический поток выполнения принадлежал только одному физическому потоку в операционной системе, что создает большую нагрузку на память. В итоге потоковая модель WPF осталась согласованной с существующей потоковой моделью User32 однопотокового выполнения со сходством потоков. Основной причиной этого была совместимость - такие системы, как OLE 2.0, буфер обмена и Internet Explorer все требуют одного потока сродства (STA) исполнения.  
  
 При наличии объектов с организацией потоковой обработки STA необходим способ связи между потоками и проверки нахождения в правильном потоке. В этом заключается роль диспетчера. Диспетчер — это основная система управления сообщениями, включающая несколько очередей с назначенными приоритетами. Примеры сообщений включают необработанные входящие уведомления (перемещение мыши), функции платформы (макет) или пользовательские команды (выполнение этого метода). Выражая <xref:System.Windows.Threading.DispatcherObject>из, вы создаете объект CLR, который имеет поведение STA, и будет дан указатель диспетчеру во время создания.  
  
<a name="System_Windows_DependencyObject"></a>
## <a name="systemwindowsdependencyobject"></a>System.Windows.DependencyObject  
 Одной из основных архитектурных философий, используемых при создании WPF, было предпочтение свойств, а не методов или событий. Свойства являются декларативными, и с их помощью проще указать цель, а не действие. Поддерживается также система для отображения содержимого пользовательского интерфейса на основе моделей (или данных). Такой подход обусловил создание дополнительных свойств, к которым можно осуществить привязку в целях лучшего управления поведением приложения.  
  
 Для того, чтобы иметь больше системы, управляемой свойствами, необходима более богатая система свойств, чем то, что предоставляет CLR. Простым примером такой полноты являются уведомления об изменении. Для двусторонней привязки необходимо, чтобы обе стороны привязки поддерживали уведомления об изменениях. Чтобы поведение зависело от значений свойств, необходимо получать уведомление в случае изменения значения свойства. Microsoft .NET Framework имеет интерфейс **INotifyPropertyChange**, который позволяет объекту публиковать уведомления об изменении, однако это необязательно.  
  
 WPF обеспечивает более богатую систему <xref:System.Windows.DependencyObject> свойств, полученную от типа. Система свойств действительно является системой свойств "зависимостей" в том смысле, что она отслеживает зависимости между выражениями свойств и автоматически проверяет значение свойства при изменении зависимости. Например, если у вас есть наследуемое свойство (например), <xref:System.Windows.Controls.Control.FontSize%2A>система автоматически обновляется, если свойство изменяется на родительском элементе, который наследует значение.  
  
 Основой системы свойств WPF является концепция выражения собственности. В этом первом выпуске WPF система выражения свойств закрывается, и все выражения предоставляются как часть платформы. Выражения объясняют, почему система свойств не поддерживает привязку к данным, создание стилей или жестко заданное наследование, но вместо этого представлена слоями более поздних версий в платформе.  
  
 Система свойств также предоставляет способ разреженного хранения значений свойств. Так как объекты могут иметь десятки (если не сотни) свойств и большинство значений находится в состоянии по умолчанию (унаследованы, задаются стилем и т. д.), не каждый экземпляр объекта должен иметь все определенные в нем свойства в полном объеме.  
  
 Наконец, последняя новая особенность системы свойств — это понятие присоединенных свойств. Элементы WPF строятся по принципу композиции и повторного использования компонентов. Часто некоторые элементы (например элемент <xref:System.Windows.Controls.Grid> макета) нуждаются в дополнительных данных о элементах ребенка для управления его поведением (например, информация строки/колонны). Вместо того чтобы сопоставлять все эти свойства с каждым элементом, любой объект может предоставить определения свойств для любого другого объекта. Это похоже на возможности expando в JavaScript.  
  
<a name="System_Windows_Media_Visual"></a>
## <a name="systemwindowsmediavisual"></a>System.Windows.Media.Visual  
 После определения системы следующим шагом является рисование пикселей на экране. Класс <xref:System.Windows.Media.Visual> предусматривает создание дерева визуальных объектов, каждый из которых дополнительно содержит инструкции по рисованию и метаданные о том, как сделать эти инструкции (отсечение, преобразование и т.д.). <xref:System.Windows.Media.Visual>предназначен для того, чтобы быть чрезвычайно легким и гибким, поэтому большинство функций не имеют публичной экспозиции API и в значительной степени полагаются на защищенные функции обратного вызова.  
  
 <xref:System.Windows.Media.Visual>действительно является отправной точкой для системы композиций WPF. <xref:System.Windows.Media.Visual>является точкой связи между этими двумя подсистемами, управляемым API и неуправляемым milcore.  
  
 WPF отображает данные, пересекая неуправляемые структуры данных, управляемые milcore. Эти структуры, называемые узлами композиции, представляют собой иерархическое дерево отображения с инструкциями по отрисовке в каждом узле. Это дерево, показанное в правой части расположенного ниже рисунка, доступно только через протокол обмена сообщениями.  
  
 При программировании WPF <xref:System.Windows.Media.Visual> создаются элементы и выведенные типы, которые внутренне передаются дереву композиций через этот протокол обмена сообщениями. Каждый из них <xref:System.Windows.Media.Visual> в WPF может создать один, ни один, ни один, ни несколько узлов композиции.  
  
 ![Windows Presentation Foundation в визуальном дереве.](./media/wpf-architecture2.PNG "wpf_architecture2")  
  
 Здесь имеется один очень важный архитектурный момент — все дерево визуальных объектов и инструкций по рисованию кэшируется. С точки зрения графики WPF использует сохраненную систему рендеринга. Это позволяет системе осуществлять перерисовку с высокой частотой без блокирования системы композиции при обратных вызовах, обращенных к коду пользователя. Это помогает предотвратить признаки неотвечающего приложения.  
  
 Другим важным моментом, который не заметен на схеме, является то, как система в действительности выполняет композицию.  
  
 В User32 и GDI система работает на немедленной системе отсечения режима. Когда требуется визуализация компонента, система устанавливает границы обрезки, вне которых компонент не может изменять пиксели, а затем компонент запрашивает рисование пикселей в этой области. Эта система работает очень хорошо в системах с ограниченной памятью, так как в случае каких-либо изменений приходится иметь дело только с измененным компонентом — два компонента никогда не воздействуют на цвет одного пикселя.  
  
 WPF использует модель живописи "алгоритм художника". Это означает, что вместо обрезки каждого компонента каждый компонент запрашивается для отрисовки, начиная с заднего плана и до переднего плана отображения. Это позволяет рисовать каждый компонент поверх отображения предыдущего компонента. Преимуществом этой модели является то, что можно создавать сложные полупрозрачные фигуры. С современным графическим оборудованием, эта модель является относительно быстрой (что не было, когда User32/ GDI были созданы).  
  
 Как упоминалось ранее, основная философия ВПФ заключается в переходе к более декларативной, "имущественной" модели программирования. В визуальной системе это проявляется в паре любопытных моментов.  
  
 Во-первых, если говорить о сохраненном режиме графической системы, он действительно отражает переход от императивной модели DrawLine/DrawLine к модели, ориентированной на данные, — new Line()/new Line(). Этот переход к управляемой данными отрисовке позволяет выполнять сложные операции в инструкциях по рисованию, выражаемых с помощью свойств. Типы, вытекающие <xref:System.Windows.Media.Drawing> из фактически объектная модель для рендеринга.  
  
 Во-вторых, оценивая систему анимации, можно увидеть, что она является практически полностью декларативной. Вместо обязательного вычисления разработчиком следующего положения или цвета можно выразить анимации как набор свойств для объекта анимации. Эти анимации могут выражать замыслы разработчика или проектировщика (переместить эту кнопку отсюда туда в течение 5 секунд), и система может определить наиболее эффективный способ для их выполнения.  
  
<a name="System_Windows_UIElement"></a>
## <a name="systemwindowsuielement"></a>System.Windows.UIElement  
 <xref:System.Windows.UIElement>определяет основные подсистемы, включая layout, входные и события.  
  
 Layout является основной концепцией в WPF. Во многих системах либо присутствует фиксированный набор моделей для макетов (HTML поддерживает три модели для макетов: поток, абсолютное значение и таблицы), либо вообще нет модели для макета (User32 в действительности поддерживает только абсолютное размещение). WPF начал с предположения, что разработчики и дизайнеры хотят гибкую, расширяемую модель макета, которая может определяться значениями свойств, а не императивной логикой. На <xref:System.Windows.UIElement> уровне вводится базовый контракт на макет - <xref:System.Windows.UIElement.Measure%2A> двухэтапная модель с и <xref:System.Windows.UIElement.Arrange%2A> проходит.  
  
 <xref:System.Windows.UIElement.Measure%2A>позволяет компоненту определить, сколько размер он хотел бы принять. Это отдельный этап, <xref:System.Windows.UIElement.Arrange%2A> потому что есть много ситуаций, когда родительский элемент будет просить ребенка измерить несколько раз, чтобы определить его оптимальное положение и размер. Тот факт, что родительские элементы просят элементы ребенка измерить, демонстрирует еще одну ключевую философию WPF - размер к содержанию. Все элементы управления в WPF поддерживают возможность размера до естественного размера их содержимого. Это значительно упрощает локализацию и позволяет осуществлять динамическую компоновку элементов в соответствии с изменением размеров. Фаза <xref:System.Windows.UIElement.Arrange%2A> позволяет родителю позиционировать и определять окончательный размер каждого ребенка.  
  
 Много времени часто тратится на разговоры о <xref:System.Windows.Media.Visual> выходе стороны WPF - и связанных с ними объектов. Однако существует также множество новшеств со стороны ввода данных. Вероятно, самым фундаментальным изменением в модели ввода для WPF является последовательная модель, по которой события ввода направляются через систему.  
  
 Ввод возникает как сигнал драйверу устройства режима ядра и направляется в нужный процесс и поток через сложный процесс, в котором участвуют ядро Windows и User32. После того, как сообщение User32, соответствующее вхвоза, направляется в WPF, оно преобразуется в необработанное вводимые сообщения WPF и отправляется диспетчеру. WPF позволяет преобразовывать необработанные входной объекты в несколько фактических событий, что позволяет внедрять такие функции, как "MouseEnter", на низком уровне системы с гарантированной доставкой.  
  
 Каждое событие ввода преобразуется по крайней мере в два события: событие предварительное и событие фактическое. Все события в WPF имеют понятие разгрома через дерево элемента. События, как говорят, "пузырь", если они пересекают от цели вверх по дереву к корню, и говорят, что "туннель", если они начинаются в корне и пройти вниз к цели. Предварительные события ввода перемещаются по нисходящей, причем любые элементы в дереве могут фильтровать или обрабатывать событие. Обычные события (не предварительные) перемещаются по восходящей от конечной точки вверх к корню.  
  
 Это разделение между нисходящим и восходящими этапами делает возможным согласованную реализацию таких возможностей, как сочетания клавиш. В User32 сочетания клавиш реализуются посредством одной глобальной таблицы, содержащей все необходимые сочетания клавиш (CTRL+N сопоставляется с командой "Создать"). В диспетчере приложения вызывается метод **TranslateAccelerator**, который будет анализировать сообщения ввода в User32 и определять их соответствие зарегистрированному сочетанию клавиш. В WPF это не будет работать, потому что система полностью "композитный" - любой элемент может обрабатывать и использовать любой ускоритель клавиатуры. Наличие такой двухэтапной модели для ввода позволяет компонентам реализовать собственные методы TranslateAccelerator.  
  
 Чтобы сделать еще <xref:System.Windows.UIElement> один шаг вперед, также вводит понятие CommandBindings. Система команд WPF позволяет разработчикам определить функциональность с точки зрения <xref:System.Windows.Input.ICommand>конечной точки команды - то, что реализует. Привязки команд позволяют элементу определять соответствие между действием ввода (CTRL+N) и командой ("Создать"). И действия ввода, и определения команд являются расширяемыми и могут быть связаны вместе во время использования. Это делается, например, для того чтобы конечный пользователь мог легко настраивать привязки клавиш, которые ему необходимо использовать в приложении.  
  
 На данный момент в теме, "основные" особенности WPF - функции, реализованные в сборке PresentationCore, были в центре внимания. При создании WPF, чистое разделение между основополагающими частями (например, контракт на макет с **Мерой** и **Аранжировать)** и рамочными частями (например, реализация определенной компоновки, как) <xref:System.Windows.Controls.Grid>было желаемым результатом. Целью являлось предоставление точки расширяемости внизу стека, что позволило бы внешним разработчикам при необходимости создавать свои собственные платформы.  
  
<a name="System_Windows_FrameworkElement"></a>
## <a name="systemwindowsframeworkelement"></a>System.Windows.FrameworkElement  
 <xref:System.Windows.FrameworkElement>можно рассматривать двумя различными способами. Он вводит набор политик и настроек в подсистемах, введенных в нижних слоях WPF. В нем также вводится набор новых подсистем.  
  
 Основная политика, <xref:System.Windows.FrameworkElement> введенная вокруг макета приложения. <xref:System.Windows.FrameworkElement>опирается на базовый контракт <xref:System.Windows.UIElement> макета введения и добавляет понятие макета "слот", что делает его легче для авторов макета иметь последовательный набор свойств инициативе семантики макета. Свойства, <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> <xref:System.Windows.FrameworkElement.VerticalAlignment%2A>как <xref:System.Windows.FrameworkElement.MinWidth%2A>, <xref:System.Windows.FrameworkElement.Margin%2A> , и (назовем несколько) дают все компоненты, полученные от <xref:System.Windows.FrameworkElement> последовательного поведения внутри контейнеров макета.  
  
 <xref:System.Windows.FrameworkElement>также обеспечивает более легкое воздействие API на многие функции, найденные в основных слоях WPF. Например, <xref:System.Windows.FrameworkElement> обеспечивает прямой доступ <xref:System.Windows.FrameworkElement.BeginStoryboard%2A> к анимации с помощью метода. A <xref:System.Windows.Media.Animation.Storyboard> предоставляет способ скрипт нескольких анимаций против набора свойств.  
  
 Двумя наиболее <xref:System.Windows.FrameworkElement> важными вещами, которые вводят являются связывания данных и стили.  
  
 Подсистема связывания данных в WPF должна быть относительно знакома любому, кто использовал формы Windows или ASP.NET для создания приложения. [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] В каждой из этих систем есть простой способ выразить, что одно или несколько свойств данного элемента необходимо привязать к элементу данных. WPF имеет полную поддержку привязки собственности, преобразования и привязки списка.  
  
 Одной из наиболее интересных особенностей связывания данных в WPF является внедрение шаблонов данных. Шаблоны данных позволяют декларативно указывать способ визуализации фрагмента данных. Вместо создания настраиваемого пользовательского интерфейса, который может быть привязан к данным, можно обойти проблему и позволить данным определять способ отображения.  
  
 Создание стилей — это облегченная форма привязки данных. Посредством создания стилей можно привязать набор свойств из общего определения к одному или нескольким экземплярам элемента. Стили применяются к элементу либо по <xref:System.Windows.FrameworkElement.Style%2A> явной ссылке (путем установки свойства), либо неявно связывая стиль с типом элемента CLR.  
  
<a name="System_Windows_Controls_Control"></a>
## <a name="systemwindowscontrolscontrol"></a>System.Windows.Controls.Control  
 Наиболее значимая возможность для элемента управления — это использование шаблонов. Если представлять себе систему композиции WPF как систему отрисовки сохраненного режима, то шаблоны позволяют элементу управления описывать свою отрисовку в параметризированной, декларативной форме. A <xref:System.Windows.Controls.ControlTemplate> на самом деле является не чем иным, как скриптом для создания набора элементов ребенка, с привязками к свойствам, предлагаемым элементом управления.  
  
 <xref:System.Windows.Controls.Control>предоставляет набор свойств запасов, <xref:System.Windows.Controls.Control.Foreground%2A>, <xref:System.Windows.Controls.Control.Background%2A>чтобы <xref:System.Windows.Controls.Control.Padding%2A>назвать несколько, какие шаблоны авторы могут использовать для настройки отображения элемента управления. Реализация элемента управления обеспечивает модель данных и модель взаимодействия. Модель взаимодействия определяет набор команд (таких как "Закрыть" для окна) и привязки к действиям ввода (таким как нажатие красного символа X в верхнем углу окна). Модель данных предоставляет набор свойств либо для настройки модели взаимодействия, либо для настройки отображения (определяется шаблоном).  
  
 Это разделение между моделью данных (свойства), моделью взаимодействия (команды и события) и моделью отображения (шаблоны) позволяет полностью настроить внешний вид и поведение элемента управления.  
  
 Типичным аспектом модели данных элементов управления является модель содержимого. Если вы посмотрите <xref:System.Windows.Controls.Button>на элемент управления, как, вы увидите, <xref:System.Object>что он имеет свойство под названием "Содержание" типа . В формах Windows и ASP.NET это свойство, как правило, является строкой, которая, однако, ограничивает тип содержимого, которое можно поместить в кнопку. Содержимое для кнопки может представлять собой простую строку, сложный объект данных или все дерево элементов. В случае объекта данных используется шаблон данных для создания отображения.  
  
<a name="Summary"></a>
## <a name="summary"></a>Сводка  
 WPF предназначен для создания динамических систем презентации, управляемых данными. Каждая часть системы предназначена для создания объектов с помощью наборов свойств, которые определяют их поведение. Привязка данных является основополагающей частью системы и интегрирована на каждом уровне.  
  
 Традиционные приложения создают отображение, а затем привязывают его к некоторым данным. В WPF все, что связано с управлением, каждый аспект дисплея, генерируется некоим типом связывания данных. Текст внутри кнопки отображается путем создания составного элемента управления внутри кнопки и привязки его отображения к свойству содержимого кнопки.  
  
 Когда вы начинаете разработку приложений на основе WPF, он должен чувствовать себя очень знакомым. Вы можете устанавливать свойства, использовать объекты и связывать данные во многом так же, как вы можете использовать формы Windows или ASP.NET. При более глубоком исследовании архитектуры WPF, вы обнаружите, что существует возможность создания гораздо более богатых приложений, которые принципиально рассматривают данные в качестве основного драйвера приложения.  
  
## <a name="see-also"></a>См. также раздел

- <xref:System.Windows.Media.Visual>
- <xref:System.Windows.UIElement>
- <xref:System.Windows.Input.ICommand>
- <xref:System.Windows.FrameworkElement>
- <xref:System.Windows.Threading.DispatcherObject>
- <xref:System.Windows.Input.CommandBinding>
- <xref:System.Windows.Controls.Control>
- [Обзор связывания данных](../../../desktop-wpf/data/data-binding-overview.md)
- [Макет](layout.md)
- [Общие сведения об эффектах анимации](../graphics-multimedia/animation-overview.md)
